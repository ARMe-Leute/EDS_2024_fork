/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stm32f401xe.h>
#include <system_stm32f4xx.h>

#include <stdint.h>
#include <stdbool.h>

#include <mcalGPIO.h>
#include <mcalUsart.h>

#define BLUETOOTH_RX
#define BLUETOOTH_TX

uint8_t *outString =  (uint8_t *) "ABCD";

void uartTest(void);
void USART2_IRQHandler(void);

int main(void)
{
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN; // GPIOA :Bustakt aktivieren
	gpioSelectPinMode(GPIOA, PIN2, ALTFUNC); // PA2 :Modus = Alt. Funktion
	gpioSelectAltFunc(GPIOA, PIN2, AF7); // PA2 :AF7 = USART2 Rx
	gpioSelectPinMode(GPIOA, PIN3, ALTFUNC); // PA3 :Modus = Alt. Funktion
	gpioSelectAltFunc(GPIOA, PIN3, AF7); // PA3 :AF7 = USART2 Tx
	gpioSelectPinMode(GPIOA, PIN5, OUTPUT); // PA5 :GPIO-Output fuer LED

	// Hier werden sÃ¤mtliche Parameter (Baudrate, Wortlaenge, Paritaet und
	// Anzahl der Stoppbits eingestellt.
	usartSelectUsart(USART2);
	usartEnableUsart(USART2);
	usartSetCommParams(USART2, 115200, NO_PARITY, LEN_8BIT, ONE_BIT);
	usartEnableIrq(USART2, USART_IRQ_RXNEIE);

	NVIC_EnableIRQ(USART2_IRQn);
	__enable_irq();
	/* Loop forever */
	for(;;);
}

void USART2_IRQHandler(void)
{
	uint16_t received = 0;
	if (USART2->SR & USART_SR_RXNE)
	{
		received = USART2->DR & 0x01FF;
		if (received == 'a')
		{
			gpioSetPin(GPIOA, PIN5);
		}
		if (received == 'b')
		{
			gpioResetPin(GPIOA, PIN5);
		}
		if ((received >= 'A') && (received <= 'Z'))
		{
			USART2->DR = received;
		}
		if (received == 'c')
		{
			USART2->CR1 |= USART_CR1_TXEIE;
			USART2->DR = *outString++;  // Liest alle Zeichen des
			// vordefinierten Strings
		}
	}

	if (USART2->SR & USART_SR_TXE)
	{
		if (*outString != '\0')
		{
			USART2->DR = *outString++;
		}
		else
		{
			USART2->CR1 &= ~USART_CR1_TXEIE;
		}
	}
}
